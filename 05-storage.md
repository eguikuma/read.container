<div align="right">
<img src="https://img.shields.io/badge/AI-ASSISTED_STUDY-3b82f6?style=for-the-badge&labelColor=1e293b&logo=bookstack&logoColor=white" alt="AI Assisted Study" />
</div>

# 05-storage：ストレージ

## はじめに

[04-network](./04-network.md) では、コンテナがどうやって通信するかを学びました

bridge、veth ペア、ポートマッピングにより、コンテナは外部や他のコンテナとネットワーク通信ができます

しかし、コンテナにはもう1つ重要な課題があります

[03-image](./03-image.md) で学んだように、コンテナのファイルシステムは<strong>コンテナレイヤ</strong>（書き込み可能レイヤ）に書き込まれます

このコンテナレイヤは、コンテナが削除されると<strong>一緒に消えてしまいます</strong>

- データベースのデータ
- アプリケーションのログ
- ユーザーがアップロードしたファイル

これらをコンテナの削除とともに失うわけにはいきません

このトピックでは、コンテナでデータを永続化する仕組みを学びます

---

## 日常の例え

コンテナのストレージを「ホテルの部屋」に例えてみましょう

<strong>コンテナレイヤ（一時的なストレージ）</strong>

ホテルの部屋に備え付けの<strong>メモ帳</strong>のようなものです

滞在中に自由に書き込めますが、チェックアウト（コンテナ削除）すると、メモ帳はクリーニングされて白紙に戻ります

<strong>ボリューム</strong>

ホテルの<strong>金庫</strong>のようなものです

金庫の中身はチェックアウトしても保管されます

次に同じホテルに泊まったとき（新しいコンテナを起動したとき）、金庫の中身をまた使えます

<strong>バインドマウント</strong>

<strong>自分の荷物を部屋に持ち込む</strong>ようなものです

自宅（ホスト）から持ってきた本やノートを、ホテルの部屋（コンテナ）で直接使います

部屋に書き込んだ内容は、自宅のノートにそのまま残ります

---

## このページで学ぶこと

このページでは、以下の概念を学びます

<strong>コンテナのファイルシステム</strong>

- <strong>コンテナレイヤ</strong>
  - コンテナ起動時に追加される書き込み可能なレイヤ
- <strong>一時性（ephemeral）</strong>
  - コンテナ削除時にデータが失われる仕組み

<strong>データの永続化</strong>

- <strong>ボリューム</strong>
  - Docker が管理する永続ストレージ
- <strong>バインドマウント</strong>
  - ホストのファイルやディレクトリをコンテナにマウント
- <strong>tmpfs マウント</strong>
  - メモリ上の一時的なファイルシステム

<strong>ストレージの実装</strong>

- <strong>ストレージドライバ</strong>
  - コンテナのファイルシステムを実現する仕組み

---

## 目次

1. [コンテナのファイルシステム](#コンテナのファイルシステム)
2. [なぜデータの永続化が必要か](#なぜデータの永続化が必要か)
3. [ボリューム](#ボリューム)
4. [バインドマウント](#バインドマウント)
5. [tmpfs マウント](#tmpfs-マウント)
6. [ボリューム・バインドマウント・tmpfs の比較](#ボリュームバインドマウントtmpfs-の比較)
7. [ストレージドライバ](#ストレージドライバ)
8. [次のトピックへ](#次のトピックへ)
9. [用語集](#用語集)
10. [参考資料](#参考資料)

---

## コンテナのファイルシステム

[03-image](./03-image.md) で学んだように、コンテナのファイルシステムは以下の構造になっています

```
┌──────────────────────────────────────┐
│ コンテナレイヤ（書き込み可能）        │ ← コンテナ固有
├──────────────────────────────────────┤
│ イメージレイヤ（読み取り専用）        │ ← イメージ由来
├──────────────────────────────────────┤
│ イメージレイヤ（読み取り専用）        │ ← イメージ由来
└──────────────────────────────────────┘
```

コンテナ内でのファイル操作は、すべてコンテナレイヤに記録されます

- ファイルの新規作成 → コンテナレイヤに書き込まれる
- 既存ファイルの変更 → イメージレイヤからコピーされた後、コンテナレイヤで変更される（Copy-on-Write）
- ファイルの削除 → コンテナレイヤにホワイトアウトファイルが作成される

### コンテナレイヤの特徴

| 特徴         | 説明                                                       |
| ------------ | ---------------------------------------------------------- |
| 書き込み可能 | コンテナ内のすべてのファイル変更がここに記録される         |
| コンテナ固有 | 同じイメージから起動した別のコンテナとは独立               |
| 一時的       | コンテナが削除されると、コンテナレイヤも削除される         |
| 性能         | Copy-on-Write のオーバーヘッドがあり、直接書き込みより遅い |

---

## なぜデータの永続化が必要か

コンテナは「作って壊して作り直す」ことが前提の技術です

イメージを更新したり、設定を変更したりする際、古いコンテナを削除して新しいコンテナを起動します

しかし、以下のようなデータはコンテナのライフサイクルとは独立して保持する必要があります

| データの例                     | なぜ永続化が必要か                         |
| ------------------------------ | ------------------------------------------ |
| データベースのデータ           | コンテナを再起動してもデータを失いたくない |
| アプリケーションのログ         | 障害調査のためにログを保持したい           |
| ユーザーのアップロードファイル | ユーザーのデータはコンテナの寿命と無関係   |
| 設定ファイル                   | コンテナの再作成時に同じ設定を使いたい     |

これらの要件を満たすために、Docker は<strong>ボリューム</strong>と<strong>バインドマウント</strong>という仕組みを提供しています

---

## ボリューム

<strong>ボリューム</strong>は、Docker が管理する永続ストレージです

コンテナのライフサイクルとは独立してデータを保持します

### ボリュームの作成と使用

```
docker volume create my-data

docker run -v my-data:/var/lib/data myapp
```

この例では、`my-data` という名前のボリュームを作成し、コンテナの `/var/lib/data` にマウントしています

### ボリュームの保存場所

ボリュームのデータは、ホストのファイルシステム上に保存されます

Docker の場合、デフォルトでは `/var/lib/docker/volumes/` ディレクトリの下に保存されます

```
/var/lib/docker/volumes/
  └── my-data/
      └── _data/
          └── （ボリュームのデータ）
```

### ボリュームの特徴

| 特徴                 | 説明                                                    |
| -------------------- | ------------------------------------------------------- |
| Docker が管理        | Docker が保存場所を管理する。ユーザーはパスを意識しない |
| コンテナ間で共有可能 | 複数のコンテナから同じボリュームをマウントできる        |
| コンテナ削除時に残る | コンテナを削除してもボリュームのデータは保持される      |
| バックアップが容易   | Docker コマンドでボリュームのバックアップや移行ができる |

### ボリュームのライフサイクル

```
ボリューム作成 ──→ コンテナにマウント ──→ コンテナ削除 ──→ ボリュームは残る
                                                              │
                                              新しいコンテナにマウント可能
                                                              │
                                              明示的に削除するまで存在する
```

ボリュームはコンテナとは独立して管理されるため、コンテナを削除してもデータは失われません

新しいコンテナを起動して同じボリュームをマウントすれば、以前のデータがそのまま使えます

---

## バインドマウント

<strong>バインドマウント</strong>は、ホストの任意のファイルやディレクトリを、コンテナの指定したパスにマウントする仕組みです

### バインドマウントの使用

```
docker run -v /home/user/config:/etc/app/config myapp
```

この例では、ホストの `/home/user/config` をコンテナの `/etc/app/config` にマウントしています

コンテナからこのパスにアクセスすると、ホストのファイルが直接見えます

### バインドマウントの特徴

| 特徴                   | 説明                                                                           |
| ---------------------- | ------------------------------------------------------------------------------ |
| ホストのパスを直接使用 | Docker を介さず、ホストのファイルシステムを直接マウント                        |
| 双方向                 | コンテナからの変更はホストに反映され、ホストからの変更もコンテナに反映される   |
| 開発環境で便利         | ソースコードをバインドマウントすれば、編集がリアルタイムにコンテナに反映される |
| セキュリティリスク     | コンテナからホストのファイルシステムに直接アクセスできるため、注意が必要       |

### ボリュームとバインドマウントの違い

```
ボリューム：
  ホスト  /var/lib/docker/volumes/my-data/_data/
                    │
                    └── コンテナ /var/lib/data にマウント
  （Docker が管理するパス）

バインドマウント：
  ホスト  /home/user/config/
                    │
                    └── コンテナ /etc/app/config にマウント
  （ユーザーが指定する任意のパス）
```

---

## tmpfs マウント

<strong>tmpfs マウント</strong>は、ホストのメモリ上に一時的なファイルシステムを作成し、コンテナにマウントする仕組みです

### tmpfs マウントの使用

```
docker run --tmpfs /tmp myapp
```

この例では、コンテナの `/tmp` にメモリ上のファイルシステムをマウントしています

### tmpfs マウントの特徴

| 特徴                 | 説明                                                                     |
| -------------------- | ------------------------------------------------------------------------ |
| メモリ上に存在       | ディスクには書き込まれない                                               |
| 高速                 | メモリアクセスのためディスクより高速                                     |
| コンテナ停止で消える | コンテナが停止するとデータが失われる                                     |
| セキュリティ         | 機密データ（パスワード、トークン等）をディスクに残さない用途に適している |

---

## ボリューム・バインドマウント・tmpfs の比較

| 項目              | ボリューム                | バインドマウント       | tmpfs マウント           |
| ----------------- | ------------------------- | ---------------------- | ------------------------ |
| 保存場所          | Docker 管理のディレクトリ | ホストの任意のパス     | メモリ                   |
| データの永続性    | コンテナ削除後も残る      | ホスト上に残る         | コンテナ停止で消える     |
| Docker による管理 | あり                      | なし                   | なし                     |
| コンテナ間の共有  | 可能                      | 可能                   | 不可                     |
| 主な用途          | データベース、永続データ  | 開発環境、設定ファイル | 一時ファイル、機密データ |
| 性能              | 良い                      | 良い（ネイティブ I/O） | 最速（メモリアクセス）   |

### どれを使うべきか

- <strong>データを永続化したい</strong> → ボリューム
- <strong>ホストのファイルをコンテナで使いたい</strong> → バインドマウント
- <strong>一時的なデータをメモリに置きたい</strong> → tmpfs マウント
- <strong>迷ったら</strong> → ボリューム（Docker が管理してくれるため、最も安全で扱いやすい）

---

## ストレージドライバ

<strong>ストレージドライバ</strong>は、コンテナのレイヤ構造と Copy-on-Write を実現するカーネルレベルの仕組みです

### ストレージドライバの役割

ストレージドライバは、イメージレイヤとコンテナレイヤを管理し、コンテナから見える統合されたファイルシステムを提供します

[03-image](./03-image.md) で学んだ overlay filesystem は、ストレージドライバの1つです

### 主なストレージドライバ

| ドライバ       | カーネル機能           | 特徴                                                          |
| -------------- | ---------------------- | ------------------------------------------------------------- |
| overlay2       | overlayfs              | 現在の標準。ほとんどの Linux ディストリビューションでサポート |
| fuse-overlayfs | FUSE + overlayfs       | rootless コンテナ向け。ユーザー権限で動作可能                 |
| btrfs          | Btrfs ファイルシステム | Btrfs のスナップショット機能を利用                            |
| zfs            | ZFS ファイルシステム   | ZFS のスナップショット機能を利用                              |

### overlay2 の動作

overlay2 は [03-image](./03-image.md) で学んだ overlayfs を使います

```
merged（コンテナから見えるファイルシステム）
  │
  ├── upperdir（コンテナレイヤ）
  │
  └── lowerdir（イメージレイヤ）
```

コンテナが起動すると、overlay2 がイメージレイヤを lowerdir に、コンテナレイヤを upperdir に設定し、merged でファイルシステムを統合します

### ボリュームとストレージドライバの関係

ボリュームとストレージドライバは異なる仕組みです

|               | ストレージドライバ             | ボリューム               |
| ------------- | ------------------------------ | ------------------------ |
| 管理対象      | イメージレイヤとコンテナレイヤ | 永続化したいデータ       |
| Copy-on-Write | あり                           | なし（直接書き込み）     |
| 性能          | CoW のオーバーヘッドあり       | ネイティブのファイル I/O |
| 永続性        | コンテナ削除で消える           | コンテナ削除でも残る     |

I/O が頻繁なデータ（データベースなど）は、ストレージドライバ（CoW）ではなくボリューム（直接書き込み）を使うことで性能を向上できます

---

## 次のトピックへ

このトピックでは、以下のことを学びました

- コンテナのファイルシステムは一時的であり、コンテナ削除でデータが失われる
- ボリュームは Docker が管理する永続ストレージで、コンテナのライフサイクルとは独立
- バインドマウントはホストのファイルを直接コンテナにマウントする
- tmpfs マウントはメモリ上の一時ファイルシステムを提供する
- ストレージドライバ（overlay2）がレイヤ構造と Copy-on-Write を実現する

ここまでで、コンテナの主要な構成要素を学びました

- コンテナの正体（01）
- ランタイムによる管理（02）
- イメージの仕組み（03）
- ネットワーク通信（04）
- データの永続化（05）

しかし、コンテナが<strong>安全に</strong>動作するためには、セキュリティの仕組みも理解する必要があります

次のトピック [06-security](./06-security.md) では、<strong>コンテナのセキュリティ</strong>を学びます

capability、seccomp、rootless コンテナなど、コンテナを安全に運用するための多層防御の仕組みを理解します

---

## 用語集

| 用語                   | 説明                                                                                  |
| ---------------------- | ------------------------------------------------------------------------------------- |
| コンテナレイヤ         | コンテナ起動時にイメージの上に追加される書き込み可能なレイヤ。コンテナ削除で消える    |
| 一時性（ephemeral）    | コンテナのファイルシステムがコンテナのライフサイクルと結びついている性質              |
| ボリューム             | Docker が管理する永続ストレージ。コンテナのライフサイクルとは独立してデータを保持する |
| バインドマウント       | ホストの任意のファイルやディレクトリをコンテナの指定パスにマウントする仕組み          |
| tmpfs マウント         | ホストのメモリ上に一時的なファイルシステムを作成し、コンテナにマウントする仕組み      |
| ストレージドライバ     | イメージレイヤとコンテナレイヤの管理、Copy-on-Write を実現するカーネルレベルの仕組み  |
| overlay2               | 現在標準のストレージドライバ。overlayfs を使ってレイヤ構造を実現する                  |
| fuse-overlayfs         | rootless コンテナ向けのストレージドライバ。FUSE を使ってユーザー権限で動作する        |
| Copy-on-Write（CoW）   | 読み取り専用データを変更する際にコピーを作成してから変更する方式                      |
| ホワイトアウトファイル | overlayfs でファイルの削除を表現するための特殊なマーカーファイル                      |

---

## 参考資料

このページの内容は、以下のソースに基づいています

<strong>マウント</strong>

- [mount(2) - Linux manual page](https://man7.org/linux/man-pages/man2/mount.2.html)
  - マウントシステムコール
- [mount_namespaces(7) - Linux manual page](https://man7.org/linux/man-pages/man7/mount_namespaces.7.html)
  - Mount namespace の仕組み

<strong>tmpfs</strong>

- [tmpfs(5) - Linux manual page](https://man7.org/linux/man-pages/man5/tmpfs.5.html)
  - メモリベースのファイルシステム

<strong>Docker ストレージ</strong>

- [Docker storage overview](https://docs.docker.com/engine/storage/)
  - ボリューム、バインドマウント、tmpfs マウントの概要
- [Docker storage drivers](https://docs.docker.com/engine/storage/drivers/)
  - ストレージドライバ（overlay2 等）の仕組み
